# 堆
包括正常的堆Stack和特殊的堆如最小堆(通常以优先队列形式出现PriorityQueue)

// 丑数||
编写一个程序，找出第 n 个丑数。丑数就是质因数只包含 2, 3, 5 的正整数。
示例:
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

丑数的排列顺序是从小到大的，所以可以使用优先队列处理，在JAVA中使用最小堆的形式实现，同时也可以通过对comparator进行修改改造成最大堆。
需要做几个事:
1.将后续丑数入堆,因为丑数是2/3/5的乘积,所以对于当前的一个值,分别乘上2/3/5就是下三个丑数
2.但是1中可能会带来2个问题:其一是重复如2*3=3*2，可以用HashSet解决,其二是大小顺序,这个由优先队列自己解决了
下边这个题解用了long类型，因为测试样例里有很大的值,所以这里修改了，此外也提一下对long类型的处理:
常数转long类型,在数字后加个L即可,如1L
public int nthUglyNumber(int n) {
	int[] nums = new int[n + 1];
	HashSet<Long> set = new HashSet<>();
	PriorityQueue<Long> pq = new PriorityQueue<>();

	// 加入第一个丑数
	pq.add(1L);
	set.add(1L);

	// 初始化丑数和因子
	long currUgly = 1L,newUgly = 1L;
	int[] primes = new int[]{2,3,5};

	// 从堆中包含一个数字开始
	// 重复该步骤计算所有丑数。
	for (int i = 0; i < n; i++) {
		currUgly = pq.poll();
		nums[i] = (int)currUgly;
		for (int prime : primes) {
			newUgly = currUgly * prime;
			if (!set.contains(newUgly)){
				set.add(newUgly);
				pq.add(newUgly);
			}
		}
	}
	return nums[n - 1];
}
这里比较巧妙的是primes数组的构建,因为每次都需要乘2/3/5并判断set并入队,所以可以用一个大小为3的数组,每次对数组内容乘积,得到结果,十分值得学习.


## TOP K问题
一般都是求前K个元素，这类通常可以用优先队列解决，通过最小堆或者修改的最大堆或者将反向获取len-K个内容来得到答案。
当然对于TOP K问题，实际上是排序问题，这里涉及到很多的排序算法，都是需要掌握的。见排序.md，要了解他们各自适用于什么场景。

//前K个高频元素
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

要做几个事情:
1. 存数和数出现的次数
2. 找出频率前K高的元素内容返回
这里很清晰是两块内容，1.明显是通过哈希表实现的，不赘述
对于2.这里实际上涉及到排序了，对频率进行排序，那么对于排序就有很多种方法，从而衍生出各类解题方法。
比较简洁的方法是利用优先队列的特性
优先队列实际上是一个堆(根据自定义comparator构建最小堆或最大堆),在JAVA中使用PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>()建立,不指定comparator时默认是最小堆,即以二叉树形式存储,构建最小堆,堆顶是最小值,每次poll出来的内容是最小值,每次add后,都会自动将顺序进行排序.
heap.peek()//返回堆顶值,默认为最小值
heap.poll()//将堆顶值取出,默认为最小值
heap.add()//向堆中加入元素
heap.size()//查看堆大小
heap.isEmpty()//查看是否为空
一共有5种方法可以使用.
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<Integer,Integer>();
        int[] ans = new int[k];
        for(int num : nums)
            map.put(num, map.getOrDefault(num, 0) + 1);
        PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>() {
            // 重定义比较器,从map获取内容进行比较,这个是十分重要的!!!,因为我们要从表里把对应的频率进行比较
            @Override
            public int compare(Integer a, Integer b) {
                return map.get(a) - map.get(b);
            }}
            );
        for(int key : map.keySet()){
            if(heap.size() < k){
                heap.add(key);
            }else if(map.get(key) > map.get(heap.peek())){
                heap.remove();
                heap.add(key);
            }
        }
        for(int j = 0; j < k; j++){
            ans[k - 1 -j] = heap.remove();
        }
        return ans;
    }
}
```

// 数组中的第K个大的元素
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
public int findKthLargest(int[] nums, int k) {
	if(nums.length == 0) return 0;
	PriorityQueue<Integer> q = new PriorityQueue<>();
	for(int i = 0; i < nums.length; i++) q.add(nums[i]);
	for(int i = 0; i < nums.length - k; i++) q.poll();
	return q.poll();
}

// 有序矩阵的第K小的元素
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。
public int kthSmallest(int[][] matrix, int k) {
	int ans = 0;
	PriorityQueue<Integer> q = new PriorityQueue<>();
	for(int i = 0; i < matrix.length; i++){
		for(int j = 0; j < matrix[0].length; j++){
			q.add(matrix[i][j]);
		}
	}
	for(int i = 0; i < k; i++){
		ans = q.poll();
	}
	return ans;
}