# 二分查找
一般用于有序的数组进行查找，当然有时也不需要有序，见例题。

//求幂Pow(x, n)
实现 pow(x, n) ，即计算 x 的 n 次幂函数。
示例 1:
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25

使用快速幂算法:
把幂运算拆分成n/2下取整的相关运算。这样只需要判断n的值的奇偶性即可，如果是奇数则需要额外乘以x的值；偶数则需要对n/2的内容乘积即可。
-->此外有个判别问题，简化成n>=0的操作即可，对n<0时进行翻转取反即可。
-->一个坑，对于超大测试用例1.00000 -2147483648，会出现溢出问题，因为2^32的正反范围不是一样的，负数范围小1，直接取反会溢出。所以可以将int直接修改为long类型，这样可取的范围就扩大了，降低了溢出风险。

递归版本，每次递归的时候只要判断是不是奇偶就好了。
public double myPow(double x, int n) {
	long N = n;
	return n >= 0 ? calcuPow(x, N) : 1.0 / calcuPow(x, -N);
}

public double calcuPow(double x, long n){
	if (n == 0) {
		return 1.0;
	}
	double y = calcuPow(x, n / 2);
	return n % 2 == 0 ? y * y : y * y * x;
}

迭代版本同理，只不过注意迭代顺序是逆序就好了从i到0，一直除2。
public double myPow(double x, int n) {
	double res = 1.0;
	for(int i = n; i != 0; i /= 2){
		if(i % 2 != 0){
			res *= x;
		}
		x *= x;
	}
	return  n < 0 ? 1 / res : res;
}

//最长重复子数组
给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
示例：
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1]。

解法1:
比较好理解的滑动窗口，每次用最小的那个数组A滑动判断AB是否有重复内容。主要有三种情况：
1.A整段在B的首尾范围之内
2.A的后段和B的前端重合
3.A的前段和B的后段重合
分好三段后，就可以直接对重合段进行数组是否一致的判断了，可以看出，需要输入的是数组A/A起始位置/数组B/B起始位置/重叠段长度
而对于重复内容判断，在i=1~length，判断是否一致，一致则count++，否则count重新清零，这样可以保证把中间重合的长度也获取到。
public int findLength(int[] A, int[] B) {
	int ans = 0;
	int an = A.length, bn = B.length;
	for(int i = 0; i <= bn - an; i++) ans = Math.max(ans, maxLength(A, B, 0, i, an));
	for(int i = an; i > 0; i--) ans = Math.max(ans, maxLength(A, B, 0, bn - i, i));
	for(int i = 1; i <= an; i++) ans = Math.max(ans, maxLength(A, B, an - i, 0, i));
	return ans;
}

public int maxLength(int[] A, int[] B, int Astart, int Bstart, int length){
	int ans = 0, count = 0;
	for(int i = 0; i < length; i++){
		if(A[Astart + i] == B[Bstart + i]){
			count++;
			ans = Math.max(count, ans);
		}
		else
			count = 0;
	}
	return ans;
}

解法2：
更加进阶的算法是dp。
https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/yi-zhang-biao-ba-ju-hua-kan-dong-dong-tai-gui-hua-/
求最长重复子串问题实际上是有第二种普适方法的，就是构建一个二维表d[i][j]，表示A字符串前i个和B字符串前j的最长重复子串。把行列相同值对应的十字交界处标记下来，那么题目实际上就是求最大斜线长度，同时也可以优化一下。
-->对于每次判断，如果当前Ai和Bj是一样的，如果在此之前的最大长度不为0，即前斜线有值，那就意味着当前字符可以加上，所以长度+1；否则的话，当前的内容只可能是起始，重新计算，当前值记为1,实际上也是长度+1，因为之前左上是0。
那么dp公式就有了
if(s1.charAt(i) == s2.charAr(j))
	dp[i][j] = dp[i-1][j-1] + 1;
else
	dp[i][j] = 0;
	
**这个题解比较特殊，选了从后往前的版本来写**
public int findLength(int[] A, int[] B) {
	int n = A.length, m = B.length;
	int[][] dp = new int[n + 1][m + 1];
	int ans = 0;
	for (int i = n - 1; i >= 0; i--) {
		for (int j = m - 1; j >= 0; j--) {
			dp[i][j] = A[i] == B[j] ? dp[i + 1][j + 1] + 1 : 0;
			ans = Math.max(ans, dp[i][j]);
		}
	}
	return ans;
}

顺序版本:
public int findLength(int[] A, int[] B) {
	int n = A.length, m = B.length;
	int[][] dp = new int[n + 1][m + 1];
	int ans = 0;
	for (int i = 1; i <= m; i++) {    // base case的情况，初始化时已包括了
		for (int j = 1; j <= n; j++) {
			if (A[i - 1] == B[j - 1]) {     
				dp[i][j] = dp[i - 1][j - 1] + 1;  // A[i-1]!=B[j-1]的情况，初始化时已包括，全部置成了0
			}
			res = Math.max(dp[i][j], res);
		}
	}
}

// 寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
示例 1:
输入: [1,3,4,2,2]
输出: 2
示例 2:
输入: [3,1,3,4,2]
输出: 3

找到数组中的重复整数，可以有很多种办法，这里主要讲下二分和快慢指针的方法。
1. 排序后比较
2. 哈希集合
3. 二分查找
根据这个题目的特性，可以用二分的方法，主要的切入点在于:这个重复的数字会带来什么呢？
对象是1~n的数字，如果出现了某个重复数字，那么在某个区间里，<=i的数字就会超过i，即因为重复带来了数量的超出。那么就可以通过这个来进行二分缩短判断的范围，知道缩短到目标值。
public int findDuplicate(int[] nums) {
	if(nums.length == 0) return -1;
	int left = 0;
	int right = nums.length - 1;
	while(left < right){
		int mid = (left + right) / 2;
		int count = 0;
		for (int num: nums){
			if(num <= mid){
				count++;
			}
		}
		if(count > mid) right = mid;
		else left = mid + 1;
	}
	return left;
}
4. 快慢指针
