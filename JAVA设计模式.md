# JAVA设计模式

简单设计模式讲就是：某些场景下，针对某类问题的某种通用的解决方案。

- 场景：项目所在的环境
- 问题：约束条件，项目目标等
- 解决方案：通用、可复用的设计，解决约束达到目标。

## 分类

- 创建型模式：把**对象实例化**的模式，创建型模式用于解耦对象的实例化过程。
- 结构型模式：把类或对象结合在一起**形成更大的结构**。
- 行为型模式：**类和对象如何交互，划分责任**和算法。

## 创建型模式

### 单例模式

为了确保**某一个类只有一个实例**，并且提供**一个全局访问点**。

因此当系统中只需要一个实例对象或者只允许一个公共访问点，可以使用单例模式。


单例模式的主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。

但这导致了单例类职责过重，违背了“单一职责原则”，同时也没有抽象类，所以扩展起来有一定的困难。

#### 实现方式

1. 懒汉式(需要的时候才调用new实例)，线程不安全
不支持多线程，因为没有加锁 synchronized，所以严格意义上它并不算单例模式。

这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

```java
public class Singleton {  
	// 类内private的对象
    private static Singleton instance;
	// 私有构造方法,外部无法使用,保证一个类只有一个实例
    private Singleton (){}  
	// 对外暴露的唯一公共访问入口,只有在需要的时候才new这个唯一的实例
    public static Singleton getInstance() {  
		if (instance == null) {  
			instance = new Singleton();  
		}
		return instance;  
    }  
}
```

2. 懒汉式，线程安全

在1.的基础上把getInstance方法加个synchronized关键字
```java
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
		if (instance == null) {  
			instance = new Singleton();  
		}  
		return instance;  
    }  
}
```

3. 饿汉式(常用,但没有达到lazy loading效果,因为类装载时就实例化了,而不是需要了才创建)

优点：没有加锁，执行效率会提高。

缺点：类加载时就初始化，浪费内存，容易产生垃圾对象。

```
public class Singleton {  
	// 直接new一个,典型的饿汉式,而不是在全局入口getInstance中被调用才新建
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
		return instance;  
    }
}
```

4. 双检锁/双重校验锁（DCL，即 double-checked locking）

这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。

双锁的内容是：1. 实例singleton用volatile修饰; \2. Singleton.class这个返回的class对象用synchronized修饰 

```
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
		if (singleton == null) {  
			synchronized (Singleton.class) {  
				if (singleton == null) {  
					singleton = new Singleton();  
				}
			}
		}  
		return singleton;  
    }
}
```

5. 登记式/静态内部类（lazy loading效果）

这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化。

如果实例化 instance 很消耗资源，所以想让它延迟加载，此外，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载。

那么实例化 instance 显然是不合适的。此时，这种方式相比第 3 种方式就显得很合理。

```
public class Singleton {  
    private static class SingletonHolder {  
		private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
		return SingletonHolder.INSTANCE;  
    }  
}
```

6. 枚举enum

没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。

它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。

不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。

不能通过 reflection attack 来调用私有构造方法。

```
// 注意是enum,而不是class
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```

### 工厂模式

先定义一个创建对象的接口，然后让其子类自己决定实例化哪一个工厂类，而工厂类通过调用接口实现实例新建。

这个工厂模式使其创建过程延迟到子类进行。

啥意思？指的是明确要在不同情况下创建不同实例，让创建实例过程在工厂类的子类中实现。

实例：

1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 

2、Hibernate 换数据库只需换方言和驱动就可以。

优点：

1、一个调用者想创建一个对象，只要知道其名称就可以了。

2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。

3、屏蔽产品的具体实现，调用者只关心产品的接口。

缺点：

每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

使用场景：

1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。

2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。

3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。

复杂对象适合使用工厂模式，而简单对象，**特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式**。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

#### 实现方式

1. 步骤1

创建一个接口(interface):

```
// Shape.java
public interface Shape {
   void draw();
}
```
2. 步骤2

创建实现接口的三个实体类(implements是继承接口内容,可以implement多个接口,这里implement的接口shape带的是draw方法,可以重写)。

```
// Rectangle.java
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}

// Square.java
public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}

// Circle.java
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```

3. 步骤3

创建一个工厂类，生成基于给定信息的实体类的对象。

```
// ShapeFactory.java
public class ShapeFactory {
    
   //使用 getShape 方法的入参shapeType获取对应类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }
	  // 通过shapeType new新的实例
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```
4. 步骤4

测试文件，调用该工厂，通过传递类型信息来新建实例。
```
// FactoryPatternDemo.java
public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}

// 结果为
// Inside Circle::draw() method.
// Inside Rectangle::draw() method.
// Inside Square::draw() method.
```

### 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

应用实例(双重工厂套娃)：

工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。

假设一种情况，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。

所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

### 建造者模式(把系统分为模块，各自组合)

将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。使用多个简单的对象一步一步构建成一个复杂的对象。

应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。

### 原型模式

用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。

例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 结构型模式

### 适配器模式

在应用程序中可能需要将两个不同接口的类进行通信，在不修改这两个类的前提下添加中间件来完成衔接。

这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成另一个类期望的另一个接口。

### 桥接模式

如果说某个系统能够从多个角度来进行分类，且每一种分类都可能会变化，那么我们需要做的就是将这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合，这个分离过程就使用了桥接模式。

所谓桥接模式就是把抽象部分和实现部分隔离开来，使得他们能够独立变化。

它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

桥接模式将继承关系转化成关联关系，封装了变化，完成了解耦，减少了系统中类的数量，也减少了代码量。

### 过滤器模式(标准模式)

这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。

它结合多个标准来获得单一标准。

### 组合模式

组合模式组合多个对象形成**树形结构**以表示“整体-部分”的结构层次。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

在使用组合模式中需要注意一点也是组合模式最关键的地方：

**叶子对象和组合对象实现相同的接口，树枝和叶子实现统一接口，树枝内部组合该接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。**

虽然组合模式能够清晰地定义分层次的复杂对象，也使得增加新构件也更容易，但是这样就导致了系统的设计变得更加抽象，如果系统的业务规则比较复杂的话，使用组合模式就有一定的挑战了。

### 装饰器模式(继承的替代方案)

我们可以通过继承和组合的方式来给一个对象添加行为，虽然使用继承能够很好拥有父类的行为，但是它存在几个缺陷：一、对象之间的关系复杂的话，系统变得复杂不利于维护。二、容易产生“类爆炸”现象。三、是静态的。在这里我们可以通过使用装饰者模式来解决这个问题。

装饰者提供了继承的替代方案，能够**动态将责任附加到对象上，将原始对象作为参数传给装饰器的构造器**。

### 代理模式

在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

为其他对象提供一种代理以控制对这个对象的访问。

简单说是在这个类上面封装了一个中间层，这个中间层代理控制下层的类。

**在一个代理类中创建被代理对象的实例。**和装饰器有区别。

代理类中创建代理对象，由代理控制实例使用；而装饰器把装饰对象传入构造器。

### 外观模式

如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用。

外观模式提供了一个统一的接口，用来访问子系统中的一群接口。

它给子系统提供了一个简单、单一的屏障，客户通过这个屏障来与子系统进行通信。

通过使用外观模式，使得客户对子系统的引用变得简单了，实现了客户与子系统之间的松耦合。但是它违背了“开闭原则”，因为增加新的子系统可能需要修改外观类或客户端的源代码。

### 享元模式

主要用于减少创建对象的数量，以减少内存占用和提高性能。用 HashMap 存储这些对象。

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。

## 行为型模式

### 责任链模式

为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

### 命令模式

请求以命令的形式包裹在对象中，并传给调用对象。

调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口方式

### 解释器模式

这种模式实现了一个表达式接口，该接口解释一个特定的上下文。

这种模式被用在 SQL 解析器、符号处理引擎等。

构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。

### 迭代器模式

是Java中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

定义接口：hasNext, next。

### 中介者模式

用来降低多个对象和类之间的通信复杂性。

这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。

对象之间的通信封装到一个类中单独处理。

### 备忘录模式

保存一个对象的某个状态，以便在适当的时候恢复对象。类似于游戏存档。

### 观察者模式

当对象间存在**一对多关系**时，则使用观察者模式。比如，当一个对象被修改时，则会自动通知依赖它的对象。

在抽象类里有一个 ArrayList 存放观察者们。

### 状态模式

类的行为是基于它的状态改变的。

在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的上下文 context 对象。

### 空对象模式

使用一个空对象取代 NULL 对象实例的检查。

Null 对象不是检查空值，而是反应一个不做任何动作的关系。

这样的 Null 对象也可以在数据不可用的时候提供默认的行为。

在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类。

还创建一个未对该类做任何实现的空对象类。

该空对象类将无缝地使用在需要检查空值的地方。

### 策略模式

一个类的行为或其算法可以在运行时更改。

创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。

策略对象改变会导致 context 对象的改变。

### 模板模式

一个抽象类公开定义了执行它的方法的方式/模板，让子类重写使用。

它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

### 访问者模式

我们使用了一个访问者类，它改变了元素类的执行算法。

通过这种方式，元素的执行算法可以随着访问者改变而改变。

根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。

### MVC 模式

MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。

- Model - 模型代表一个存取数据的对象或 JAVA 

- POJO。它也可以带有逻辑，在数据变化时更新控制器。

- View - 视图代表模型包含的数据的可视化。

- Controller - 作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。

### 业务代表模式

用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。

- 客户端（Client） - 表示层代码可以是 JSP、servlet 或 UI java 代码。

- 业务代表（Business Delegate） - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。

- 查询服务（LookUp Service） - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。

- 业务服务（Business Service） - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。

### 组合实体模式

组合实体模式用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。

- 组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。

- 粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。

- 依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。
策略（Strategies） - 策略表示如何实现组合实体。

### 数据访问对象模式

数据访问对象模式或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。

- 数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。

- 数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。

- 模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。

### 前端控制器模式

前端控制器模式是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。

该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。

以下是这种设计模式的实体。

- 前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。

- 调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。
视图（View） - 视图是为请求而创建的对象。

### 拦截过滤器模式

拦截过滤器模式用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。

- 过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。

- 过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。
Target - Target 对象是请求处理程序。

- 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。
客户端（Client） - Client 是向 Target 对象发送请求的对象。

### 服务定位器模式

服务定位器模式用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。

- 服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。

- Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用。

- 服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。

- 缓存（Cache） - 缓存存储服务的引用，以便复用它们。

- 客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象。

### 传输对象模式

传输对象模式用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。

- 业务对象（Business Object） - 为传输对象填充数据的业务服务。

- 传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。

- 客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。