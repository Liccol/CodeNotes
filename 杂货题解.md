# 杂货题解
// 使数组唯一的最小增量
给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。

返回使 A 中的每个值都是唯一的最少操作次数。

示例 1:

输入：[1,2,2]
输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
示例 2:

输入：[3,2,1,2,1,7]
输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。

实际上要做多少步？把数组排序，然后将每个变成后一个比前一个大1，这样操作步数是最少的，为什么是这样？
增量实际上就等于最终形态的数字和-原数字和，数字和不变，只要让最终形态数字和越少，增量就越少，最少的情况就是排序排下来，如果左右相同，使右边大1就好，如果左<右就别动。
1. 排序后遍历处理
排序后，可能有两种情况：1.左小于右，那没问题；2.左大于右，把右改成左+1的值
public int minIncrementForUnique(int[] A) {
	Arrays.sort(A);
	int ans = 0;
	for(int i = 1; i < A.length; i++){
		if(A[i - 1] >= A[i]){
			ans += A[i - 1] - A[i] + 1;
			A[i] = A[i - 1] + 1;
		}
	}
	return ans;
}
2. 计数处理
基本思路是构建一个数组，把数的出现次数和最大的数记录下来。每次操作的时候，把重复出现的数的counts-1个直接加一，然后下一个位置的数量也随之变化，直到所有数组的counts值都只是1。
这种处理有个思考的界限问题，如果你记录了最大值，理论上你可以用他来做边界，但是要特别处理，因为每次都加个增量，他可能越过最大值，怎么处理？
-->因为每次都+1，所以最后只可能是在边界处有多个数重复，只要去判断这个位置他有多少个，然后单独的一次修改成递增数列就好了。public int minIncrementForUnique(int[] A) {
    int[] count = new int[40000];
    int max = 0;
    for (int a : A) {
        count[a]++; // 计数
        max = Math.max(max, a); // 计算数组中的最大值
    }
    
    int res = 0;
    for (int j = 0; j < max; j++) {
        if (count[j] > 1) {
            // 有 count[j] - 1 个数需要增加
            res += count[j] - 1; 
            count[j+1] += count[j] - 1;
        }
    }
    
    // count[max] 单独计算，是因为可能超出 40000 的边界
    if (count[max] > 1) {
        int d = count[max] - 1; 
        // 有 d 个数需要增加
        // 分别增加为 max + 1, max + 2, ... max + d
        // 使用等差数列公式求和
        res += (1 + d) * d / 2;
    }
    
    return res;
}

// 最佳观光组合
给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。

一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。

返回一对观光景点能取得的最高分。

这道题给的很直接A[i] + A[j] + i - j，求这个的最大值，暴力解超时。
为什么超时？有两个for循环，想一下实际上这个式子，不变的一直实际上是for循环中的A[j]-j，在当前环时这个不变，需要去找最大的A[i]+i，所以可以加入一个mx元素从A[0]+0开始，单一for循环的i变化时，同步把最大的A[i]+i更新掉就好了。

public int maxScoreSightseeingPair(int[] A) {
	int ans = 0, mx = A[0] + 0;
	for(int i = 1; i < A.length; i++) {
		ans = Math.max(ans, mx + A[i] - i);
		mx = Math.max(A[i] + i, mx);
	}
	return ans;
}

